gRPC Queue
Queue framework for gRPC
27 Aug 2018
Tags: grpc queue

Peter P. Gengler
Principal Software Engineer, JumpCloud
https://github.com/ppg
https://go-talks.appspot.com/github.com/ppg/grpc-queue/20180828.slide


* Who am I?

- Engineer at JumpCloud.
- Directory as a Service; think next-gen AD in the cloud.
- Located in downtown Boulder; next to Boulder Theater, across from courthouse.
- We're hiring!
.image 1-JumpCloud-Wide-Montage.jpg 300 _
#.image Happy-Holidays-from-JumpCloud-2017.jpg 300 _


* What are we trying to solve?

- Industry trend towards microservices
- Good for separation of concern, horizontal scaling, etc.
- Large, distributed system can have (micro)services fail somewhat often.
- Synchronous requests aren't durable; can do retries, but have limits.
- Introduce durable queue, work off that queue.


* Queue Frameworks

Similar to how you pick an http framework (http package, martini, negroni,
etc.) to handle common functionality, you can pick from various queue
frameworks:

[[https://www.goworker.org/]]:

- Made to operate with Resqueue (from the Ruby world).
- Utilizes existing serialization/deserialization definitions.
- Registers workers, but not type-safe.

[[https://github.com/RichardKnop/machinery]]:

- Arbitrary message format with serialization/deserialization provided.
- Plugable backend brokers (redis, rabbitmq, etc.)
- Registers workers, but not type-safe.

And many more ...


* Why a Queue Framework?

Take a step back and ask what we want:

- Automatic Serialization/Deserialization of requests provided.
- Ability to register handlers for requests; i.e. users.Insert, users.Delete, etc.
- [bonus] Type safety to avoid casting and type checking.
- [bonus] Abstraction of queue system -> brokers.

Basically we'd like to write the unique code for a queue worker and not write
any of the boilerplate code.

This sounds like ...


* gRPC!

Looking back: [[https://go-talks.appspot.com/github.com/ppg/grpc-intro/grpc-intro.slide]]

Per that talk, [[http://www.grpc.io/][gRPC]] is really about making type-safe,
generated code around an IDL (protobuf) so that we implement only the
functionality of the endpoints and none of the 'glue' code. Specifically:

- IDL to define messages and RPCs (request/response).
- Implementation of server (over HTTP/2) and ability to register RPC handlers for requests.
- Implementation of client (over HTTP/2) and ability to send RPC requests.

That's all our goals, but over a queue instead of HTTP/2!


* gRPC Queue

- Same IDL for gRPC; side-effect will be ease of synchronous + asynchronous services.
- Introduce concept of Broker: transport for messages, such as SQS.
- Introduce concept of Queue: named unit of production/consumption.
- Implementation of consumer and ability to register RPC handlers for messages.
- Implementation of producer and ability to produce RPC messages.

* IDL for testing

.code proto/test.proto

* Test service implementation

  type testService struct {}

  func (testService) (ctx context.Context, req *pb.TestRPCRequest) (*pb.TestRPCResponse, error) {
    return &pb.TestRPCResponse{Message: req.Message}, nil
  }

- Implement the RPCs in a Test service; user written.
- `pb` package auto-generated from grpc library.
- Normal ability to inject dependencies, implementation based on application logic, etc.
- Type-safe requests and responses with (some) validation.


* gRPC Server

  // Listen on a TCP port
  listener, err := net.Listen("tcp", ":8080")

  // Create gRPC server and register test proto services
  server := grpc.NewServer()
  pb.RegisterTestServer(server, service)

  // Serve requests
  grpc.Serve(listener, server)

- Listen on a port; stdlib code.
- Create gRPC server; grpc library code.
- Register Test service; grpc generated code; uses user-written implementation.
- Serve requests; grpc library code.


* gRPC Consumer

  // Create a queue and broker
  queue := inmemory.NewQueue("test-queue")
  broker, err := inmemory.NewBroker(10, queue)

  // Create gRCP consumer and register test proto services
  consumer := grpcqueue.NewConsumer()
  pb.RegisterTestConsumer(consumer, service)

  // Consume requests
  grpc.Consume(broker, queue, consumer)

- Dial a broker and queue; inmemory test helper, could be SQS, REDIS, etc.; grpcqueue library code (or 3rd party).
- Create gRPC consumer; grpcqueue library code.
- Register Test service; grpcqueue generated code; uses user-written implementation.
- Consume requests; grpcqueue library code.


* gRPC Client
  // Connect to a server
  conn, _ := grpc.Dial("grpc.example.com")

  // Created typed-client and send
  client := pb.NewTestClient(conn)
  req := &pb.TestRPCRequest{Message: "Hello World"}
  resp, err := client.TestRPC(context.Background(), req)
  if err != nil {
    log.Fatalf("Could not send message: %s", err)
  }
  log.Printf("response: %+v", resp)

- Dial a server; grpc library code.
- Create a typed-client; grpc generated code.
- Create a typed-request; grpc generated code and user values.
- Send request; grpc generated code.


* gRPC Producer

  // Create a queue and broker
  queue := inmemory.NewQueue("test-queue")
  broker, err := inmemory.NewBroker(10, queue)

  // Create typed-producer and enqueue
  producer := pb.NewTestProducer(broker, queue)
  req := &pb.TestRPCRequest{Message: "Hello World"}
  err := producer.EnqueueTestRPC(context.Background(), req)
  if err != nil {
    log.Fatalf("Could not enqueue message: %s", err)
  }

- Dial a broker and queue; inmemory test helper, could be SQS, REDIS, etc.; grpcqueue library code (or 3rd party).
- Create a typed-producer; grpcqueue generated code.
- Create a typed-request; grpc generated code and user values.
- Enqueue request; grpcqueue generated code.

* Summary

- gRPC-like patterns for asynchronous requests
- Shares a lot of generated code with gRPC so trivial to support an API and a Worker.
- Additional features not show: asynchronous response path, partitioning, middleware, etc.
- Working on open-sourcing
- Questions?
